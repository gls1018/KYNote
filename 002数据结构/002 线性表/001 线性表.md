## 1. 线性表定义

线性表是具有相同数据类型的$n$个元素的有限序列

- 数据类型相同
- $n$个元素，有限， 不是无限
- 序列，有前后顺序关系



线性表只是一种逻辑结构，不是存储结构。

运算的定义是针对逻辑结构的，运算的具体实现是针对存储结构的



补充:

- 线性表中位序从 $1$ 开始， 下标从 $0$ 开始
- 插入、删除、查找等操作指的是位序，不是下标



## 2. 顺序表



### 2.1定义

静态分配定义

```cpp
#define MaxSize 100
typedef struct
{
    ElemType data[MaxSize];
    int length;
}SqList;
```

动态分配定义

```cpp
#define InitSize 100
typedef struct
{
    ElemType *data;
    int MaxSize, length;
}SqList;

//初始化
SqList L;
L.data = (ElemType*)malloc(sizeof(SqList)*InitSize);
```



顺序表优点

- 可以随机访问
- 存储密度高

顺序表缺点

- 插入和删除需要移动大量元素，插入操作平均需要移动$\frac{n}{2}$个元素
- 顺序存储分配需要一段连续的内存空间



### 2.2 基本操作实现

#### 2.2.1 插入操作

在顺序表的第 $i$ 个位置插入元素 $e$,若 $i$ 的值不合法则返回false。

```cpp
bool ListInsert(SqList &L, int i, Elemtype e)
{
    if(i < 1 || i > L.length+1)
        return false;
    if(L.Length >= MaxSize)
        return false;
    for(int j = L.length -1; j>=i; j--)
    {
        L.data[j] = L.data[j-1]
    }
    L.data[i-1] = e;
    L.length ++;
    return true;
}
```



最好情况: i = L.length + 1; 不用移动元素;时间复杂度 $o(1)$

最差情况: i = 1; 需要移动 $n$ 个元素; 时间复杂度 $o(n)$



平均情况:

假设 $p_i$ 是在第 $i$ 个位置上插入元素的概率，那么

$$
p_i = \frac{1}{n+1}
$$

平均移动的节点次数为

$$
\sum_{i=1}^{n+1} p_i(n+1-i) = p_i * \sum_{i=1}^{n+1}(n-i+1) = \frac{1}{n+1} * \frac{(n+1)*n}{2} = \frac{n}{2}
$$


#### 2.2.2 删除操作

删除顺序表L中第 $i$ 个位置的元素，使用引用变量 $e$ 返回， 若 $i$ 的输入值不合法，返回false



```cpp
bool ListDelete(SqList & L, int i, ElemType & e)
{
    if(i<1 || i>L.length)
        return false;
    e = L.data[i];
    for(int j=i; j<L.length; j++)
        L.data[j-1] = L.data[j];
    L.length --;
    return true;
}
```



最好情况: i=n; 移动元素 0 个

最差情况: i =1; 移动元素 n-1 个

平均情况:

设 $p_i$ 是删除第 $i$ 个元素的概率， 则 $p_i = \frac{1}{n}$; 删除第 $i$ 元素需要移动节点的数量为 $n-i$; 

平均移动节点数量为

$$
\sum_{i=1}^{n}p_i(n-i) = \frac{1}{n}*\frac{n(n-1)}{2} = \frac{n-1}{2}
$$

#### 2.2.3 按值查找

在顺序表中查找第一个值为 $e$ 的元素,返回其位序

```cpp
int LocateElem(SqList L, ElemType e)
{
    int i;
    for(i=0; i<L.length; i++)
    {
        if(L.data[i] == e)
            return i+1
    }
    return 0;
}
```

最好情况: $e$ 在表头; 查找一次

最差情况: $e$ 在表尾；查找 $n$ 次

平均情况：

设 $p_i$ 是查找元素在第 $i$ 个位置上概率, 则 $p_i = \frac{1}{n}$; 需要查找 $i$ 个元素

平均次数为

$$
\sum_{i=1}^{n}p_i * i = \frac{1}{n} * \frac{n(n+1)}{2} = \frac{n+1}{2}
$$

## 3.链表

### 3.1 单链表

#### 3.1.1 定义

```cpp
typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;
```



#### 3.1.2 基本操作实现

链表包含以下基本操作

- 初始化
- 求表长
- 按序号查找节点
- 按值查找节点
- 插入节点操作
- 删除节点操作

**1. 单链表的初始化**

```cpp
bool InitLinkList(LinkList &L)
{
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;
    return true;
}
```



**2. 求表长**

```cpp
int Length(LNode *L)
{
    int len = 0;
    LNode *p = L->next;
    while(p != NULL)
    {
        ++len;
        p = p->next;
    }
    return len;
}
```

- 时间复杂度为 $o(n)$

- 单链表的长度不包括头节点



**3. 按序号查找节点**

```cpp
LNode *GetElem(LNode*L, int i)
{
    LNode * p = L;
    int j = 0;
    while(p != NULL && j<i)
    {
        p = p->next;
        j++
	}
    return p;
}
```

时间复杂度o(n)



**4. 按值查找节点**

```cpp
LNode * LocateElem(LNode *L, ElemType e)
{
    LNode *p = L->next;
    while(p!= NULL && p->data !=e)
        p = p->next;
    return p;
}
```

时间复杂度o(n)



**5. 插入节点操作**

将一个节点插入到第i个位置上

```cpp
bool ListInsert(LNode *L, int i, ElemType e)
{
    LNode *p = L; //用p来保存第i-1个节点
    int j=0;
    while(p!=NULL && j<i-1)
    {
        p=p->next;
        j++
	}
    if(p==NULL)
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

时间复杂度为O(n)

**6. 删除第i个节点**

```cpp
bool ListDelete(LinkList& L, int i, ElemType&e)
{
    LNode *p = L;  //*p为第i个节点的前驱
    int j=0;
    while(p->next!=NULL && j<i-1)
    {
        p = p->next;
        j++
    }
    if(p->next == NULL || j>i-1) //i值不合法
        return false;
    LNode * q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
```



删除指定节点 *P 

思想: 找到节点 *P 的前驱，然后执行删除操作，时间复杂度为 O(n).

下面的时间复杂度为O(1)

```cpp
LNode * q = p->next;
p->data = q->data;
p->next = q->next;
free(q);
```



**7. 采用头插法建立单链表**

头插法就是每次插入新节点的时候，从头部插入

```cpp
LinkList List_HeadInsert(LinkList & L)
{
	LNode * s;
    int x;
    
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;
    scanf("%d", &x);
    while(x!=9999)
    {
        s = (LNode*)malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
	}
    return L;
}
```

采用头插法，读取的数据和生成的链表中的元素的顺序是反的，可以实现链表的逆置。

[LeetCode: 206 翻转链表](https://leetcode.cn/problems/reverse-linked-list/description/)



**8. 采用尾插法建立单链表**

尾插法就是每次插入新节点的时候，从尾部插入

```cpp
LinkList List_TailInsert(LinkList & L)
{
	int x;
    L = (LNode *)malloc(sizeof(LNode));
    LNode * s = L;
    LNode * r = L; //r作为表尾指针
    
    scanf("%d", &x);
    while(x != 9999)
    {
        s = (LNode *)malloc(sizeof(LNode));
        s ->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;
    return L;
}
```

尾插法需要一个辅助变量来保存表尾指针。

### 3.2 双链表

#### 3.2.1 定义

双链表在单链表的基础上增加了一个 $prior$ 指针来指向前驱。

```cpp
typedef struct DNode
{
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinkList;
```

#### 3.2.2 基本操作实现

**1. 插入操作**

在节点P后面插入一个节点*s



```cpp
s->next = p->next;
s->prior = p;
p->next->prior = s;
p->next = s;
```



**2. 删除操作**

删除p节点的后继节点*q

```cpp
p->next = q->next;
q->next->prior = p;
free(q);
```



### 3.3 循环链表

**1. 循环单链表**

循环单链表是在单链表的基础上，然后最后一个节点的next指针指向头节点。



- 循环单链表的判空条件是`L->next == L`



**2. 循环双链表**

在双链表的基础上，让头节点的prior指向表尾节点。

### 3.4 静态链表

用数组来描述线性表的链式存储结构

定义

```cpp
#define MaxSize 50

typedef struct
{
    ElemType data;
    int next;
}SLinkList [MaxSize];
```

静态链表以 next == -1作为结束标志。

插入、删除操作只需要修改next指针，不需要移动元素.



