## 1. 同步和互斥的概念

**临界资源**：一次只能为一个进程使用的资源就叫临界资源，比如打印机



```cpp
while(1)
{
    entry section;
    critical section;
    exit section;
    remainder section;
}
```

- 进入区：检查临界资源是否可进，若可进，则设置正在访问临界资源的标志
- 临界区：访问临界资源的那段代码
- 退出区：将正在访问临界资源的标志清除
- 剩余区: 代码中其它部分





**同步：**直接制约关系，例如，A向管道中写数据，B从管道中读数据，只有A先写，B才能读，A和B同步

**互斥：**间接制约关系，例如A和B都要使用打印机资源，但是打印机一次只能被一个进程使用，A和B之间互斥。



**临界区的准则:**

- 空闲让进
- 忙则等待
- 有限等待：要保证进程在有限时间内进入临界区，不能无限等待
- 让权等待：（原则上应该，但非必须）当进程不能进入临界区，应该让出CPU，防止进程忙等



## 2. 实现临界区的方法



### 2.1 软件实现方法

- 单标志法
- 双标志检查法
- 双标志后检查法
- PeterSon算法















### 2.2 硬件实现方法

- 中断屏蔽方法
- 硬件指令方法 -- TestAndSet指令
- 硬件指令方法 -- Swap指令









#### 2.2.1 中断屏蔽方法

因为CPU只会在发生中断时才会引起进程切换，因此关闭中断，能够保证当前运行的进程顺利执行完临界区代码。执行完后再开中断

```
...
关中断
临界区
开中断
...
```

缺点:

- 限制了CPU的交替执行程序的能力，效率明显降低
- 将关中断的权限交给用户很不明智，若一个进程关中断后不开中断，系统会崩溃
- 不适用与多处理器系统，一个CPU上关中断，不影响进程在其他CPU上执行临界区代码



#### 2.2.2 硬件指令方法 -- TestAndSet指令

```cpp
boolean TestAndSet(boolean *lock)
{
    boolean old;
    old = *lock;
    *lock = true;
    return old;
}
```



为临界资源设置了一个共享变量lock,表示该资源的两种状态：

- true 表示被占用（已加锁）
- false表示空闲（未加锁）

将lock视为一把锁，进程在进入临界区之前，先用TS指令检查lock值

- 若为false,表示没有进程在临界区，可进入,并将lock设置为true
- 若为true, 表示有进程在临界区，进入循环等待



使用TS指令实现互斥的过程如下:

```cpp
while(TestAndSet(&lock))
    ;
临界区代码...
lock = false;  //解锁
进程其他代码...
```



### 3. 互斥锁



### 4. 信号量

Wait和Sigal, 也叫PV操作

- P表示申请资源
- V表示释放资源



**整形信号量**

定义一个表示资源数量的整形量 S；

```
Wait(s)
{
	while(s <= 0)
		;
	s = s -1;
}

Signal(S)
{
	S = S+1;
}
```



缺点：

- 当 S <=0 时， Wait操作一直在While循环里面，进程忙等， 没有遵循让权等待原则



**记录型型号量**

```
typedef struct{
	int value;
	struct process * L;
}semaphore;


void Wait(semaphore S)
{
	s.valve--;
	if(s.valve <0)
		add this process to S.L
		block (S.L)
}



void Signal(semaphore S)
{
	s.valve++;
	if(s.valve <=0)
		remove a process P from S.L
		WakeUp P
}
```







利用信号量实现同步和互斥



### 5. 生产者消费者问题

- 桌子上有一个盘子

- 妈妈一次只能往盘子里放一个橘子

- 爸爸一次只能往盘子里放一个苹果

- 儿子只吃苹果

- 女儿只吃橘子
- 盘子里只能放一个水果



分析:

- 四个进程, 盘子是临界资源
- 爸爸和妈妈是互斥关系，爸爸和儿子是同步关系，妈妈和女儿是同步关系



```cpp
semaphore palte = 1;
semaphore apple = 0;
semaphore orange = 0;

void Mom()
{
    while(1)
    {
        准备一个橘子
    	P(plate);
    	把橘子放入盘子...
    	V(orange);
    }
}

void Dad()
{
    while(1)
    {
        准备一个苹果
    	P(plate);
    	把苹果放入盘子...
   		V(apple);
    }
}

void daughter()
{
    while(1)
    {
    	P(orange);
        从盘子中取走橘子
    	...
    	V(plate);
        吃掉橘子
    }
}

void Son()
{
    while(1)
    {
        P(apple);
        从盘子中取走苹果...
        V(plate);
        吃掉苹果
    }
}
```







### 6. 读者写者问题

有读者和写者两者进程共享一个文件，要求如下:

- 允许多个读者进程对文件进行读操作
- 一次只允许一个写进程执行写操作
- 任意一个写者进程在完成写操作之前，不允许其他进程执行读和写操作
- 写进程执行写操作前，应该让已有的读者和写者全部退出。



分析:

- 写者和读者是互斥的
- 写者和写者也是互斥的
- 读者和读者不存在互斥
- 用一个计数器表示当前的读进程数量，同时要保证读进程对计数器要互斥访问



```cpp
int count = 0;       //读者计数器，
semaphore mutex = 1;
semaphore rw = 1;    //用户保证读者和写者互斥

writer()
{
    while(1)
    {
        P(rw);
        写文件...
        V(rw);
    }
}


Reader()
{
    while(1)
    {
        P(mutex);       //互斥访问 count 变量
        if(count == 0)
            P(rw);
        count ++ ;
        V(mutex);
        读文件....
        P(mutex);
        count --;
        if(count == 0)  //当最后一个读进程退出后，允许写进程写
            V(rw);
        V(mutex);
    }
}
```





### 7. 哲学家进餐问题





