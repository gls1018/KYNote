### 1. CPU的三种调度

- 高级调度（作业调度/长程调度）

  - 从外存中的作业中选一个，然后创建进程放入就绪队列
  - 每个作业的高级调度只调入一次，调出一次
  - 多道批处理系统中有高级调度，其他系统通常不需要高级调度

  

- 中级调度（内存调度）

  - 将暂时不能运行的进程调到外存等待，此时进程处于挂起状态
  - 当已具备运行条件时，由中级调度将挂起进程重新调入内存，修改状态为就绪状态并放入就绪队列

  

- 低级调度（进程调度/短程调度）

  - 按照某种算法从就绪队列中选一个进程，将CPU分配给他
  - 低级调度的频率最高，几十毫秒一次





### 2. 调度的目标

- CPU利用率
  - CPU利用率 = CPU有效工作时间 / （CPU有效工作时间 + CPU空闲等待时间）
- 系统吞吐量
  - 单位时间内CPU完成作业的数量
- 周转时间
  - 周转时间 = 作业完成时间 - 作业提交时间
- 平均周转时间
  - 平均周转时间 = （作业1周转时间 + 作业2周转时间 + ... +作业n周转时间） / n
- 带权周转时间
  - 带权周转时间 = 作业周转时间 / 作业实际运行的时间
- 平均带权周转时间
  - （作业1的带权周转时间 + ... + 作业n的带权周转时间） / n





### 3. CPU调度算法

**1. 先来先服务 FCFS**

顾名思义，在队列中选择最先到达的作业，为之创建进程放入就绪队列

特点

- 不可剥脱算法
- 不能作为分时系统和实时系统的主要调度策略



**2. 短作业优先 SJF： Short Job First**

特点

- 对长作业不利，可能会造成**进程饥饿**（一个进程长时间得不到CPU被称为进程饥饿）
- 该算法没有考虑作业的紧迫程度，不能保证紧迫性作业得到及时处理
- 该算法的平均等待时间、平均周转时间是最优的



**3. 高响应比优先调度算法**

该算法主要用于作业调度， 是FCFS和SJF算法一种综合平衡

相应比R<sub>p</sub> = (等待时间 + 要求服务时间) / 要求服务时间

特点：

- 作业等待时间相同时，运行时间越短，响应比越高，有利于短作业（类似 SJF）。
- 作业运行时间相同时，等待时间越长，响应比越高，类似于FCFS
- 对于长作业，当等待时间足够长，也可以获得CPU, 克服了 **进程饥饿**现象





**4. 时间片轮转 RR **

RR调度算法主要用于分时系统。

系统将所有就绪队列按照FCFS排成一个队列，每隔一段时间产生一次时钟中断，激活调度程序进行调度，将CPU分配给就绪队列的队首进程。

在进程执行完一个时间片后，交出CPU给下一个进程。

特点:

- 当时间片足够大的时候，RR会退化成 FCFS



**5. 多级队列调度算法**



**7. 多级反馈队列调度算法**

- 设置多个就绪队列，并为每个就绪队列赋予不同的优先级，第1级队列的优先级最高，第2级队列的优先级次之，其余队列的优先级逐个降低
- 赋予各个队列的进程运行时间片的大小各不相同，在优先级高的队列中，时间片越小
- 每个队列都采用FCFS算法，新进程进入队列后，首先将它放在第1队列的末尾，按照FCFS原则等待调度。当轮到该进程执行时，若在时间片里面完成，则撤离系统，若在一个时间片里面未完成，调度程序将其转入到第2级队列的末尾等待调度；若在第2级队列仍未完成，则转入第三级队列，当到达第n级队列后，采用时间片轮转方式运行
- 按队列优先级调度，仅当第1级队列为空时，才会调度第2级队列中的进程运行，当CPU正在执行第i级队列时，第i-1级队列进入一个进程，则会将当前进程放在第i级队列末尾，去执行第i-1级队列的进程



多级反馈队列的优势:

- 终端型作业用户： 短作业优先
- 短批处理作业用户：周转时间较短
- 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理



**8. 基于公平原则的调度算法**



### 4. 多处理机调度

两种多处理机：

- 非对称处理机AMP：CPU不同
- 对称处理机 SMP, 所有的CPU都是相同的





**处理器亲和性**

当一个进程从一个CPU转移到另一个CPU上执行时，应该将第一个CPU的缓存设置为无效,从而设置第二个CPU的缓存

这种操作的代价很高，应该避免让进程在不同的CPU上执行, 始终运行在同一个CPU上。

这个叫做`处理器亲和性`.



**负载均衡**

使每个CPU都保持均衡，不是一个CPU负载特别该，另一个CPU负载特别低



**多处理机调度方案**

公共就绪队列：

系统中设置一个公共就绪队列，所有CPU共享同一个就绪队列，负载均衡很好，处理器亲和性不好

提升亲和性的方法：

- 软亲和：调度程序尽量保持一个进程在同一个CPU上运行
- 硬亲和：用户进程通过系统调用，主动请求分配到某个CPU上



私有就绪队列:

每个CPU都有自己的就绪队列，亲和性很好，负载均衡不好

提升负载平衡方法:

推迁移：从超载的CPU的就绪队列中推一些进程到空闲CPU的就绪队列中

拉迁移: 从超载CPU的就绪队列中拉一些进程到自己的就绪队列



